# 기출 3회차 (84점)

## 03. 속성의 종류 (특성에 따른 분류)

납부 금액 속성에 의해서 발생된 진료비 합계 속성 = 파생 속성

<aside>
💡

- **기본속성** : 업무 프로세스 분석을 통해 **바로 정의가 가능**한 속성
- **설계속성** : **업무에 존재하지는 않지만** 설계하다보니 필요하다고 판단되어 **도출해낸 속성**
- **파생속성** : **다른 속성의 속성값을 계산**하거나 특정한 규칙으로 **변형**하여 생성한 속성
</aside>

## 05. ERD

1. 한명의 고객은 **여러개의 주문**을 가질 수 있음 : < : 2개 이상
2. 주문은 반드시 **하나의 고객**을 가진다 ⇒ | : 1개
3. 한명의 고객은 **~~반드시 주문**을 가진다~~ ⇒ o : 0개 ⇒ 주문이 없을 수도 있음
4. 주문 엔터티에 존재하는 고객 번호는 **일반속성**이다 ⇒ 점선 : 부모 엔터티의 실별자가 자식 엔터티의 일반속성(**비식별자**)

## 08. 컬럼 반정규화

정규화에 따라 분리되어 있던 컬럼(속성)들을 **하나의 테이블에 통합**하거나, **계산 컬럼·중복 컬럼을 추가**하는 것 ( 속성 중심 )

<aside>
💡

- 중복 컬럼 추가
- 파생 컬럼 추가
- 이력테이블 컬럼 추가
- PK에 의한 컬럼 추가
- 응용시스템 오작동을 위한 컬럼 추가
</aside>

1. 관계 컬럼 추가 ⇒ 관계 반정규화 ( 엔터티 간 관계 중심 )

## 10. 데이터 모델링

<aside>
💡

- **개념적** 데이터 모델링 : 전사적 데이터 모델링, **추상화 레벨이 가장 높음**, 업무 중심적이고 **포괄적인** 수준의 모델링
- **논리적** 데이터 모델링 : **재사용성**이 가장 높은 모델링, 데이터베이스 모델에 대한 모든 것을 표현**(Key,속성,관계 등)**
- **물리적** 데이터 모델링 : **실제 데이터베이스로 구현**할 수 있도록 성능 등 물리적 성격을 고려하여 모델을 표현
</aside>

## 11. NULL관련 함수

<aside>
💡

- **NVL**(a,b) : a가 null일 경우 b반환, 아닐 경우 a반환
  - MSSQL : ISNULL(a,b)
- **NULLIF**(a,b) : a와 b가 같으면 NULL, 아니면 a
- **NVL2**(a,b,c) : a가 null이 아닌 경우 b를 반환, null인 경우 c를 반환
- **COALESCE**(a,b,c,,,) : NULL이 아닌 최초의 인수 반환
</aside>

## 12. VIEW

<aside>
💡

- 논리적으로 존재하는 **가상 테이블** = **물리적으로 저장하지 않음**
- 사용자에게 **일부 데이터만** 공개 = **보안성**
- 테이블 구조가 변경되어도 뷰를 사용하는 응용프로그램은 변경하지 않을 수 있음 = **독립성**
- 복잡한 질의를 뷰로 생성함으로써 관련 질의를 **단순하게 작성**할 수 있음 = **편리성**
</aside>

## 14. 연산자 우선순위

<aside>
💡

1. **산술**
2. 연결
3. 비교
4. IN, LIKE, BETWEEN, IS NULL
5. NOT
6. **AND**
7. **OR**
</aside>

## 16. SQL 분류

<aside>
💡

- **DDL (정의)** : CREATE, ALTER, RENAME, DROP, TRUNCATE
- **DML (조작)** : SELECT, INSERT, UPDATE, DELETE
- **DCL (권한)** : GRANT, REVOKE
- **TCL (트랜잭션)** : COMMIT, ROLLBACK, SAVEPOINT
</aside>

## 18. CROSS JOIN

```sql
SELECT * FROM TAB1 A CROSS JOIN TAB2 B ON A.ID=B.ID; => ERROR
```

<aside>
💡

- **CROSS JOIN**은 모든 데이터의 조합을 출력하며 **별도의 ON절이 없음**
- 왼쪽 테이블의 하나의 로우가 오른쪽 테이블의 **모든 로우와 조인됨 (36번 문제)**
</aside>

## 19. TRUNCATE TABLE

<aside>
💡

- 모든 로우가 삭제 ⇒ **테이블이 삭제되는건 아님**
- 특정 로우만 **선택 삭제 불가능**
- **ROLLBACK 불가능**
- **DELETE TABLE보다 속도가 빠르고** 시스템 부하가 적음
</aside>

## 20. GROUP 함수

<aside>
💡

- **ROLLUP** : **인수 순서**에 따라 결과가 달라짐
- **CUBE** : **다차원 집계**, 시스템 부담이 큼
- ROLLUP, CUBE, GROUPING SETS **정렬 가능**
</aside>

## 21. ORDER BY

<aside>
💡

- **기본 정렬 옵션은 오름차순**
- 1,2 와 같이 컬럼과 숫자를 혼용해서 사용 가능 ⇒ **1은 첫번째 컬럼을 의미**
- DESC : 내림차순 옵션
- **SELECT구문에 사용되지 않은 컬럼도** ORDER BY에서 사용 가능
</aside>

## 22. 집합 연산자

<aside>
💡

- UNION ALL을 제외하고 집합 연산자는 **중복을 제거함**
</aside>

## 23. 윈도우 함수

<aside>
💡

- **OVER구문 필수**
- **PARTITION BY** 구문을 이용하여 집계의 대상이 되는 **레코드의 범위**를 지정할 수 있음
- 그룹내에서 순위, 집계, 비율 등을 구하여 출력
</aside>

## 28. 서브쿼리

<aside>
💡

- 서브쿼리는 **SELECT, FROM, WHERE, HAVING절** 등에서 사용할 수 있음
- 괄호로 감싸서 사용
- 메인쿼리는 서브쿼리의 컬럼을 쓸 수 ~~없음~~ (있음)⇒**FROM절에 위치(인라인뷰)할 경우 가능**
- **비연관(NON-CORRECTED) 서브쿼리의 경우 단독으로도 실행** 가능 (내 답변) ⇒ 서브쿼리가 한번만 실행되는 경우(단일실행)을 뜻함, 주로 비연관 서브쿼리에서 발생 - 연관(CORRELATED) 서브쿼리는 메인쿼리의 각 행마다 반복해서 실행됨 - EX) 메인쿼리의 ID값을 쓰면 각 값에 따라 반복 실행
</aside>

## 31. 문자형 타입

<aside>
💡

- **VARCHAR**는 비교시 서로 길이가 다를 경우 다른값이라 판단⇒ **가변형, 스페이스바를 문자로 취급**
- CHAR는 비교 시 서로 다를 경우 ~~다른값이라 판단~~ ⇒ 스페이스를 문자로 취급하지 않음 ⇒ 같은값으로 판단
- 문자형과 숫자형을 비교할 때 **문자형 데이터를 묵시적으로 숫자형으로 변환** ⇒ **문자가 숫자형태가 아닐 경우 ERR**
</aside>

## 32. GROUP BY문법과 SELCET절 컬럼 제약

```sql
SELECT ( ) , COUNT(ID)
	FROM MEMBERSHIP
	WHERE GRADE IN ('VIP','GOLD','SILVER')
		AND AGE>20
	GROUP BY GRADE;
```

1. ~~ID~~ ⇒ 집계함수에 사용하는 것이 아닌 단독은 불가능
2. ~~VIP~~ ⇒ 컬럼이 아님
3. GRADE ⇒ GROUP BY에 사용된 컬럼
4. ~~AGE~~ ⇒ 그룹 기준이 아닌 컬럼

<aside>
💡

GROUP BY를 사용할 때 SELECT에 나올 수 있는 컬럼

- **GROUP BY에 사용된 컬럼**
- **그룹함수(COUNT, SUM, AVG등) 로 집계된 컬럼**
</aside>

## 33. 날짜 조회

<aside>
💡

- **SYSDATE** : ORACLE.에서 **현재 날짜 데이터**를 반환
- +1 다음날, -1 어제 날짜
- YYYYMMDD 날짜 포맷을 위해 **TO_CHAR()형변환**
</aside>

## 34. 계층형 쿼리

<aside>
💡

- 테이블에 **계층형 데이터가 존재**하는 경우 사용 가능
- **START WITH**절은 계층 구조 전개의 **시작 위치** 지정
- **LEVEL**은 계층형 쿼리에서 사용되는 **가상 컬럼** - **루트 데이터 : 1** - 그 하위부터 +1
</aside>

## 37. 문자열 함수

<aside>
💡

- **LPAD**(STRING, LEN, PAD_STRING) : LEN까지 **왼쪽**을 **채우기**
- **RTRIM**(STRING, TRIM_CHARS) : **오른쪽**에서 TRIN_CHARS에 있는 글자들을 **제거**
  - **RTIRM(’XYZX’,’XY’) : X 또는 Y가 있으면 지움, Z에서 멈춤**
- **LTRIM**(STRING, TRIM_CHARS) :**왼쪽**에서 TRIN_CHARS에 있는 글자들을 **제거**
- **SUBSTR**(STRING, START,LEN) : 시작점부터 길이만큼 **자르기**
</aside>

## 38. UNION

<aside>
💡

- **세로 형태의 합집합**이며 **중복데이터는 하나로 출력**함
- UNION ALL보다 **속도가 느림**
</aside>

## 45. 스키마 구조

<aside>
💡

- **외부** 스키마 : **사용자** 관점
- **개념** 스키마 : **통합된** 관점
- **내부** 스키마 : **물리적** 관점, 실질적인 데이터 저장구조 등을 포함
</aside>

## 50. 비율 함수

<aside>
💡

- **PERCENT_RANK**() : **해당 파티션의 맨위 끝 행을 0, 맨아래를 1로 두고** 현재 행이 위치하는 백분위 순위 값
- **RATIO_TO_REPORT()** : **파티션별 합계**에서 차지하는 비율
- **CUME_DIST**() : 해당 파티션에서의 **누적 백분율**, **결과값이 0보다 크고 1보다 작거나 같은 값**
- **NTILE**() : 주어진 수만큼 행들을 **N등분**한 후 현재 행에 해당하는 등급을 구함
</aside>
