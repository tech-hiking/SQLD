# 4회 모의고사 정리

## 01번. 데이터 모델링의 이해

오답 : 1번 / 정답 : 2번

- (X) 논리 모델링의 외래키는 물리 모델에서 반드시 구현되어야 한다.
- (O) 논리 모델링의 외래키는 물리 모델에서 반드시 구현되지는 않는다.

### 성능상의 이유로 외래키 제약조건을 생략하는 경우

#### 1. 대용량 데이터 처리 시스템

성능상의 이유로 외래키 제약조건을 생략하는 경우가 있습니다.  
대용량 데이터 처리 시스템에서 **외래키 검증으로 인한 성능 저하를 방지**하기 위함입니다.  
애플리케이션 레벨에서 참조 무결성을 관리합니다.

```sql
-- 논리 모델: 주문과 고객 간의 외래키 관계
논리 모델: 주문(주문번호, 고객번호*, 주문일자, 금액)
         고객(고객번호, 고객명, 연락처)

-- 물리 모델: 외래키 제약조건 없이 구현
CREATE TABLE 고객 (
    고객번호 INT PRIMARY KEY,
    고객명 VARCHAR(100),
    연락처 VARCHAR(20)
);

CREATE TABLE 주문 (
    주문번호 INT PRIMARY KEY,
    고객번호 INT,  -- 외래키 제약조건 없음
    주문일자 DATE,
    금액 DECIMAL(10,2)
);
-- FOREIGN KEY 제약조건을 의도적으로 생략
```

### 데이터 웨어하우스나 분석 시스템

#### 2. ETL 프로세스에서의 외래키 생략

ETL 과정에서 대량 데이터 로딩 시 성능 향상과 배치 작업의 안정성을 위합니다.

```sql
-- 논리 모델: 판매사실과 차원 테이블들 간의 관계
논리 모델: 판매사실(판매ID, 제품ID*, 고객ID*, 날짜ID*, 판매량, 매출액)
         제품차원(제품ID, 제품명, 카테고리)
         고객차원(고객ID, 고객명, 지역)

-- 물리 모델: 외래키 없이 구현
CREATE TABLE 제품차원 (
    제품ID INT PRIMARY KEY,
    제품명 VARCHAR(100),
    카테고리 VARCHAR(50)
);

CREATE TABLE 판매사실 (
    판매ID INT PRIMARY KEY,
    제품ID INT,     -- FK 제약조건 없음
    고객ID INT,     -- FK 제약조건 없음
    날짜ID INT,     -- FK 제약조건 없음
    판매량 INT,
    매출액 DECIMAL(12,2)
);
```

### 레거시 시스템과의 연동

#### 3. 기존 시스템과의 연동

서로 다른 데이터베이스나 시스템 간의 참조는 물리적 외래키 제약조건으로 구현할 수 없을 수 있습니다.

```sql
-- 논리 모델: 신규 시스템의 주문과 기존 시스템의 고객 연결
논리 모델: 신규주문(주문ID, 레거시고객코드*, 상품코드, 수량)
         레거시고객(고객코드, 고객명)  -- 기존 시스템 테이블

-- 물리 모델: 외래키 제약조건 불가
CREATE TABLE 신규주문 (
    주문ID INT PRIMARY KEY,
    레거시고객코드 VARCHAR(20),  -- 외부 시스템 참조, FK 불가
    상품코드 VARCHAR(20),
    수량 INT
);
```

### 임시 테이블이나 스테이징 테이블

#### 4. 데이터 처리용 임시 테이블

생명주기가 짧고, 바른 처리가 우선되어 제약조건을 생략합니다.

```sql
-- 논리 모델: 처리 대상 데이터와 마스터 데이터의 관계
논리 모델: 처리대상(ID, 고객번호*, 처리상태)
         고객마스터(고객번호, 고객명)

-- 물리 모델: 임시 테이블은 외래키 없이 구현
CREATE TEMPORARY TABLE 처리대상 (
    ID INT,
    고객번호 INT,    -- FK 제약조건 없음
    처리상태 VARCHAR(20)
);
```

## 07번. 기본속성 / 파생속성

오답 : 1번 / 정답 : 3번

- 쿠폰 분류가 추가될 수 있고, 2개 이상이니 엔터티로 관리할 수 있다.
- 할인가는 파생 속성이나, 할인율은 기본 속성이다.

## 15번. ORDER BY / 정렬에 쓰일 값

Row 마다 정렬에 쓰일 값을 다르게 할 수 있다.

| ID  |
| --- |
| 100 |
| 200 |

```sql
SELECT * FROM SQLD_15
ORDER BY (CASE WHEN ID = 100 THEN 1000 ELSE ID END) DESC;
```

| ID  | 정렬에 쓰일 값 |
| --- | -------------- |
| 100 | 1000           |
| 200 | 200            |

으로, 정렬에 쓰일 값대로 정렬한다.  
따라서 내림차순으로 정렬해도, ID 정보만 오름차순으로 정렬한 것과 다르지 않다.

| ID  |
| --- |
| 100 |
| 200 |

## 16번. IN 속 NULL 연산

오답 : 4번 / 정답 : 1번

오답의 원인은 COL1이 NULL인 Row까지 고려했다.

`COL1 IN ('1', NULL)` 은 `COL1 = '1' OR COL1 = NULL` 과 같다.  
`COL1 = NULL`은 항상 `False`으로, COL1 이 NULL인 Row는 필터링 되지 않는다.

## 17번. 칼럼 수정문은 Oracle `MODIFY COLUMN`으로 암기하기

오답 : 1번 / 정답 : 2번

`ALTER TABLE ~ ALTER COLUMN ~` MySQL과 헷갈리지 않도록 주의하자.

## 32번. LAG / LEAD 암기

오답 : 2번 / 정답 : 4번

정확히 반대로 했다.

- `LAG` : 렉 걸렸다. 앞 행이 밀려서 나왔다. 따라서 앞 행을 참조한다.
- `LEAD` : 미래를 리드한다. 즉, 미래(뒤따라 오는)를 찾는다. 따라서 뒷 행을 참조한다.

## 34번. ORDER BY 절 순서

ORDER BY 절 순서는 SELECT 절의 칼럼 순서를 뜻한다.  
**FROM 테이블(또는 서브쿼리)의 순서가 아니다!**

## 39번. USING

오답 : 3번 / 정답 : 2번

- NATURAL JOIN은 JOIN 조건의 되는 칼럼은 앞에 테이블명과 ALIAS를 붙일 수 없다.
- USING은 일반 Join도 사용 가능하다.
  - 두 개의 테이블이 내부 조인으로 조인 될 때 조인하고자 하는 두 테이블의 컬럼명이 같을 경우 조인 조건을 길게 적지 않고 간단하게 적을 수 있도록 하는 역할

```sql
SELECT ~ FROM ~ A JOIN ~ B ON A.ID = B.ID

SELECT ~ FROM ~ A JOIN ~ B USING (ID)
```

# 5회 모의고사 정리

## 07번. M:N 중간 테이블의 정의

오답 : 2번 / 정답 : 3번

- M:N 중간 테이블은 **'교차 엔터티'** 라고 불린다.

## 19번. 순수 관계 연산자의 정의

오답 : 3번 / 정답 : 4번

- SELECT / PROJECT / JOIN / DIVIDE 가 있다.

| 연산자   | 연산기호  | 설명                                                                                                                                                                                                                            |
| -------- | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| SELECT   | 시그마(σ) | 릴레이션의 행에 해당하는 튜플을 구하는 것 (수평연산)                                                                                                                                                                            |
| PROJECT  | 파이(𝝿)   | 릴레이션에서 속성 리스트에 제시된 속성 값만을 추출하여 릴레이션 만든다. 단, 연산결과 중복이 발생하면 중복 제거                                                                                                                  |
| JOIN     | (▷◁)      | 공통속성을 중심으로 2개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만든다. JOIN 조건이 '=' 일때, 동일한 속성이 2번 나타나게 되는데, 이 중 중복된 속성을 제거하여 같은 속성은 1번만 나타나게 하는 연산을 자연조인 이라고 한다. |
| DIVISION | (÷)       | 두개의 릴레이션에 모두 있는 속성을 가진 튜플에서 우항에 있는 속성만 구하는 연산                                                                                                                                                 |

## 26번. 묵시적 형변환 조건

오답 : 1번 / 정답 : 4번

- (변환 O) 숫자형 칼럼 = 문자형 데이터(숫자)
- (변환 X) 문자형 칼럼 = 숫자형 데이터 -> 오류 발생

## 28번. 음수일 때 올림 / 반올림 / 내림 등

정의를 이용하자. 올림은 `x`보다 큰 정수값이다.  
-3.67 보다 큰 정수값은 -3 이다.

1차원 정수 수직선을 그리고 수보다 큰, 수보다 작은 값을 찾으면 이해가 쉽다.  
`CEIL()`은 오른쪽 정수를 찾으면 되고, `FLOOR()`은 왼쪽 정수를 찾으면 된다.

## 32번. FULL OUTER JOIN 동작 방식

오답 : 2번 / 정답 : 1번

FULL OUTER JOIN을 CROSS JOIN, 카르테시안 곱과 헷갈리지 말자.

SAMPLE2가 SAMPLE1 에 모두 포함되므로, SAMPLE1 개수만 된다.  
만약 SAMPLE2에 SAMPLE1 없는 값이 있었으면, 그것도 포함된다.  
집합 관계에서 합집합을 생각하자.

## 35번. UNION / ORDER BY

ORDER BY는 모든 UNION이 처리가 된 뒤 수행된다.

## 37번. ASC 생략 조심하기

오답 : 2번 / 정답 : 1번

`ORDER BY DEPT_NO, SALARY DESC;` 시 콤마 단위로 끊어 읽자.  
`DEPT_NO`는 ASC 이다.

## 42번. 윈도우 프레임 설정은 언제 될까?

B COL1 값에 따라 20, 30으로 처음에 예상했다.

윈도우 함수 내 ORDER BY 절이 있을 때만 윈도우 프레임 설정이 들어간다.
