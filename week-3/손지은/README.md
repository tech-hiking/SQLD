# PART1. 데이터 모델링의 이해

## CHAPTER1. 데이터 모델링의 이해

### 1. 데이터 모델

- 모델 : 현실 세계에서 일어날 수 있는 다양한 현상에 대해 일정한 표기법에 의해 표현해 놓은 모형(도식화)
- (ex) 음식을 주문하는 행위 : 고객-주문한다-상품

#### (1) 모델링

현실 세계를 반영한 모델을 단순화하여 표현한 것

- 모델링 조건

  - 현실 세계를 반영해야함
  - 단순화
  - 관리하고자 하는 데이터를 모델로 설계

- 모델링 특징

  - 추상화(Abstraction) : 현실 세계를 일정한 형식으로 표현하는 것, 아이디어나 개념을 간략하게 표현
  - 단순화(Simplification) : 복잡한 현실 세계를 정해진 표기법으로 단순하고 쉽게 표현
  - 명확화(Clarity) : 불분명함을 제거하고 명확하게 해석할 수 있도록 기술

- 모델링 기능
  - 시스템이 변화하고자 하는 모습을 가시화
  - 시스템 구축 과정에서 결정한 것을 문서화
  - 시스템을 구축하는 구조화된 틀 제공
  - 시스템 구조와 행동을 명세화
- 모델링 세 가지 관점

  - 데이터 관점(What,Data) : 어떤 데이터들이 업무와 얽혀있는지, 데이터간에는 어떤 관계가 있는지
  - 프로세스 관점(How,Process) : 업무가 실제로 처리하고 있는 일은 무엇인지, 앞으로 처리해야 하는 일은 무엇인지
  - 데이터와 프로세스의 상관 관점(Data vs. Process,Interation) : 프로세스와 데이터의 관계 위주, 프로세스의 흐름에 따라 데이터가 어떤 영향을 받는지

- 데이터 품질 유지를 위해 지양해야할 점 (모델링 시 유의)

  - 중복 : 같은 데이터가 여러 엔터티에 중복으로 저장되는 현상 지양
  - 비유연성 : 데이터 모델과 프로세스 분리
  - 비일관성 : 데이터 간의 연관 관계에 대해 명확하게 정의

- 모델링 3단계

  1. 개념적 데이터 모델링 : 전사적 데이터 모델링, 추상화 레벨이 가장 높음, 업무 중심적이고 포괄적인 수준의 모델링
  2. 논리적 데이터 모델링 : 재사용성이 가장 높은 모델링, 데이터베이스 모델에 대한 모든 것을 표현(Key,속성,관계 등)
  3. 물리적 데이터 모델링 : 실제 데이터베이스로 구현할 수 있도록 성능 등 물리적 성격을 고려하여 모델을 표현

- ANSI-SPARC아키텍처

  - 1975년 제안된 DBMS의 추상적인 설계 표준 (스키마 3단계)
  - DB에 대한 사용자들의 관점과 DB가 실제로 표현되는 물리적인 방식을 분리하기 위함
  - 사용자 입장에서는 필요한 데이터만 보고, DBA의 입장에서는 애플리케이션에 영향을 주지 않고 DB구조를 변경할 수 있어야 독립성 보장
  - [ USER - 외부 단계 - 개념 단계 - 내부 단계 - DB ]

    - 외부 스키마 : 사용자 관점, Multiple User's View, 각 사용자(응용프로그래머)가 보는 DB의 스키마
    - 개념 스키마 : 통합된 관점, Community View of DB, 모든 사용자가 보는 스키마를 통합, DB에 저장되는 데이터들을 표현하고 데이터들 간의 관계를 나타냄
    - 내부 스키마 : 물리적 관점, Physical Representation, 실질적인 데이터의 저장구조/컬럼 정의/인덱스 등을 포함한 물리적 저장구조

  - 독립성 보장
    - 논리적 독립성 : 개념 스키마가 변경되어도 외부 스키마는 영향 받지 않음
    - 물리적 독립성 : 내부 스키마가 변경되어도 외부/개념 스키마는 영향 받지 않음

- ERD(Entity Relationship Diagram)

  - 시스템에 어떤 엔터티들이 존재하며 어떤 관계가 있는지 나타내는 다이어그램
  - 작성 순서
    1. 엔터티를 도출하고 그림
    2. 엔터티 배치
    3. 엔터티간의 관계 설정
    4. 관계명을 기입
    5. 관계의 참여도를 기입
    6. 관계의 필수/선택 여부 기입
  - 표기 방식
    - Peter Chen : 주로 대학교에서 사용
    - IDEF1X : ERWin(ERD 모델링툴)에서 사용되는 모델
    - IE/Crow's Foot : 까마귀발 표기법, ERWin/ERStudio에서 사용되는 모델
    - Min-Max/ISO : 각 엔터티의 참여도 상세
    - UML : 소프트웨어 공학에서 사용
    - Case\*Method/Barker : Oracle에서 사용, Crow's Foot과 비슷

---

### 2. 엔터티(Entity)

#### (1) 정의

- 식별 가능한 객체
- 명확한 조건을 기준으로 함
- 관련 학자
  - Peter Chen : 식별할 수 있는 사물 (가장 많이 출제)
  - C.J Date : DB내에서 식별 가능한 객체, 관계형 모델의 이론가
  - James Martin : 정보를 저장할 수 있는 어떤 것
  - Thomas Bruce : 정보를 저장할 수 있는 사람, 장소, 물건, 사건 그리고 개념 등

#### (2) 구조

- 엔터티 : Table
- 인스턴스 : Row
- 속성 : Column
  - 각 엔터티는 자신을 더 상세하게 나타내기 위해 속성을 가짐

#### (3) 특징

- 업무에 쓰이는 정보여야 도출하는 의미가 있음
- 약어x, 대문자, 단수명사, 띄어쓰기x, 중복의미x
- 유니크함을 보장할 수 있는 식별자가 있어야함(각 인스턴스를 구분)
- 2개 이상의 인스턴스 o
- 반드시 속성이 있어야함
- 다른 엔터티와 1개 이상의 관계 o

#### (4) 분류

- 유형 / 무형

  - 유형 엔터티 : 물리적 형태 존재 (상품, 회원 등)
  - 개념 엔터티 : 형태 x (부서, 학과 등)
  - 사건 엔터티 : 행위를 함으로써 발생 (주문, 이벤트 응모 등)

- 발생 시점
  - 기본 엔터티 : 업무에 원래 존재, 독립적으로 생성, 자식 엔터티 o (상품, 회원, 부서 등)
  - 중심 엔터티 : 기본 엔터티에서 파생, 행위 엔터티 생성, 업무의 중심 역할 (주문, 매출, 계약 등)
  - 행위 엔터티 : 2개 이상의 엔터티로부터 파생, 자주 변경 (주문 내역, 응모 이력 등)

---

### 3. 속성(Attribute)

#### (1) 정의

- 엔터티의 특징을 나타내는 최소의 데이터 단위
- 의미상 더 이상 쪼개지지 않는 레벨
- 프로세스에 필요한 항목

#### (2) 속성값

- 하나의 속성은 한개의 속성값만 가질 수 있다
- 여러개의 속성값을 가질 경우 별도의 엔터티로 분리

#### (3) 분류

- 특성에 따른 분류
  - 기본 속성 : 바로 정의가 가능
  - 설계 속성 : 존재하지는 않지만 설계하다가 도출 (ex)학번
  - 파생 속성 : 다른 속성의 값을 계산하거나 특정한 규칙으로 변형하여 생성(보통 빠른 성능을 위해 사용), 데이터 정합성 주의 (ex) 재고
- 구성방식에 따른 분류
  - PK(Primary Key)속성 : 엔터티의 인스턴스들을 식별할 수 있는 속성
  - FK(Foreign Key)속성 : 다른 엔터티의 속성에서 가져온 속성, 다른 엔터티와의 관계의 매개체, NULL 가능
  - 일반 속성 : PK, FK 외

* 추가 용어 정리
  - 후보키 : 유일성과 최소성을 만족하는 속성 집합
  - PK : 후보키 중 하나
  - 대체키 : 후보키 중 PK가 아닌 나머지
  - 슈퍼키 : 유일성만 만족하는 집합

#### (4) 도메인

- 속성이 가질 수 있는 속성값의 범위

##### (5) 용어사전, 시스템 카탈로그

- 용어사전 : 속성명 정의 등 혼란을 예방하기 위한 업무사전
- 시스템 카탈로그 : 사용자 테이블과는 별개로 시스템 자체에 관련이 있는 데이터(메타데이터)를 담고 있는 DB, SQL로 조회(SELECT) 만 가능

---

### 4. 관계(Relationship)

#### (1) 정의

- 엔터티와 엔터티와의 관계를 의미
- 어떠한 연관성이 있는지 타입을 분류 (존재관계 / 행위 관계)
  - 존재 관계 : 존재 자체로 연관 (직원 - 부서)
  - 행위 관계 : 행위로 연관성 생성 (회원 - 주문)

#### (2) 표기법

- 관계명(Membership) : 각 엔터티의 관점에서 관계명을 하나씩 가짐 (총 2개), 현재형으로 표시
- 관계차수(Cardinality) : 관계에 참여하는 수 (1:1 , 1:M, M:N)
- 관계선택사양(Optionality) : 필수(참여자가 반드시 존재) / 선택(참여자가 없을 수도 있음)

---

### 5. 식별자(Identifiers)

- 속성 중에 각각의 인스턴스를 구분 가능하게 만들어주는 속성

#### (1) 주식별자

- PK , 기본키에 해당하는 속성
- 하나 또는 여러개가 될 수 있음
- 특징
  - 유일성
  - 최소성 : 유일성을 보장하는 최소 개수
  - 불변성
  - 존재성 : NULL불가능

#### (2) 식별자 분류

- 대표성 여부 : 주식별자 / 보조식별자
- 스스로 생성 : 내부식별자 / 외부식별자(다른 엔터티에서 온 식별자)
- 단일 속성 : 단일식별자 / 복합식별자
- 대체 여부 : 본질식별자(원조식별자,가공X) / 인조식별자(대리식별자,두개이상의 속성을 하나로 묶어서 사용)

#### (3) 식별자 관계 VS 비식별자 관계

- 식별자 관계
  - 부모엔터티의 식별자가 자식 엔터티의 주식별자가 되는 관계
  - 부모 엔터티가 있어야 생성 가능 (주식별자는 반드시 존재)
  - 단일식별자, 복합 식별자인지에 따라 1:1 또는 1:M(부모:자식)
- 비식별자 관계
  - 부모엔터티의 식별자가 자식 엔터티의 일반 속성이 되는 관계
  - 부모 엔터티가 없는 자식 엔터티 O
  - 자식 엔터티가 존재하는 상태에서 부모 엔터티 삭제 X

---

## CHAPTER2. 데이터 모델과 SQL

### 1. 정규화

- 데이터 정합성 (데이터의 정확성과 일관성을 유지하고 보장)을 위해 엔터티를 작은 단위로 분리하는 과정
- 데이터에 대한 중복성을 제거
- 정규화를 할 수 록 엔터티는 증가
- 데이터 입력,수정,삭제 성능 향상
- 데이터 조회 성능은 조건에 따라 다름 ( 지나친 정규화는 성능 저하 발생 (EX) 지나친 JOIN 필요)
- 순차적으로 1,2,3차 정규형 진행

#### (1) 제1정규형(1NF)

- 모든 속성은 반드시 하나의 값만 가져야 한다 (엔터티 분리)
- 유사한 속성이 반복되는 경우 엔터티로 분리
  - 정규화를 통해 분리하면 인덱스를 단일 속성에만 생성할 수 있어 성능과 관리에 유리
    (EX) 속성명이 인스타그램, 페이스북 등 인 경우

#### (2) 제2정규형(2NF)

- 엔터티의 모든 일반속성은 반드시 모든 주식별자에 종속되어야한다
- 주식별자가 복합식별자일 경우 일부만 종속되면 안됨
  (EX) [주문번호, 음료코드] - 음료명
  1. 음료명은 음료코드만 종속됨
  2. 주문되지 않은 음료는 입력할 수 없음 (입력 이상 현상)
  3. 음료명이 변경될 경우 해당 음료에 대한 주문 데이터가 모두 변경되어야 함 (수정 이상 현상)
- 부분 종속이 없도록 엔터티를 분리

#### (3) 제3정규형(3NF)

- 주식별자가 아닌 모든 속성 간에는 서로 종속될 수 없다 (엔터티 분리)
- BCNF(보이스-코드 정규형) : 3NF의 강화버전, 주식별자를 포함한 모든 결정자는 반드시 후보키어야한다

#### (4) 4NF, 5NF, 도메인 키 정규형(DKNF)

- 4NF : 다치 종속 제거
- 5NF : 조인 종속을 분해하여 모든 관계가 유의미하도록 분해
- DKNF : 모든 제약조건이 도메인과 키에 의해서만 표현될 수 있는 정규형

---

### 2. 반정규화

- 데이터 조회 성능을 향상시키기 위해 데이터 중복을 허용하거나 데이터를 그룹핑하는 과정
- 정규화가 끝난 후 이루어짐
- 입력, 수정, 삭제 성능 저하 가능
- 데이터 정합성 이슈 발생 가능

* 비정규화 VS 반정규화 (55p)
  - 비정규화 : 정규화가 이루어지지 않은 상태
  - 반정규화 : 정규화 구조를 다시 통합/중복 시킴
  - 테이블 관계가 강결합이어서 같이 조회되는 경우가 대부분일 경우 비정규화를 고려한다 => 처음부터 정규화를 하지않으면 비정규화, 테이블을 병합하는 의미라면 반정규화가 맞음

#### (1) 테이블 병합 (두 개 이상의 엔터티 합체)

- 1:1 관계 테이블 병합 (회원-회원상세)
- 1:M 관계 테이블 병합 (주문-주문상세) : 중복데이터가 생길 수 있음(주의)
- 슈퍼 서브 타입 테이블 병합

#### (2) 테이블 분할

- 테이블 수직 분할(속성 분할)
  - 엔터티 일부 속성을 별도의 엔터티로 분할 (1:1관계)
  - 엔터티를 가로선으로 분리한 느낌
  - 자주 사용하는 속성이 아니거나 대부분의 인스턴스가 NULL값을 가진 속성을 고려
  - 한 개의 블록에 더 많은 인스턴스를 저장할 수 있게 됨
    - 블록 : DB의 저장단위 (8KB 또는 16KB)
    - 테이블을 분할하면 레코드 하나당 사이즈가 작아지므로 더 많이 저장 가능=>I/O 비용 감소, 캐싱 향상
  - EX)회원 속성의 일부를 별도로 분리
- 테이블 수평 분할(인스턴스 분할, 파티셔닝)
  - 엔터티의 인스턴스를 특정 기준으로 별도의 엔터티로 분할(파티셔닝)
  - 테이블을 행 기준으로 쪼갬
  - 구조(스키마)는 동일하고 저장된 데이터 범위만 다름 (명확한 기준 필요)
  - 관계가 없는 다수의 테이블이 생성됨

#### (3) 테이블 추가

- 중복 테이블 추가 : 자주 조회되는 핵심 속성만 뽑아 따로 테이블을 만들어 저장 (전체 데이터를 중복)
- 통계 테이블 추가
- 이력 테이블 추가
- 부분 테이블 추가 : 특정 용도나 조건에 맞는 일부 데이터만 따로 저장 (WHERE DAY>3인 데이터만 분리 등 전체 데이터가 아닌 일부 데이터)

#### (4) 컬럼 반정규화

- 중복컬럼 추가 : JOIN이 필요한 경우가 많을 때
- 파생컬럼 추가 : 부하를 막기 위해 계산 값을 미리 컬럼에 추가
- 이력 테이블 컬럼 추가 : 대량의 이력 테이블을 조회할 때 속도가 느려질 것을 대비하여 조회 기준이 되는 컬럼을 미리 추가(EX.최신 데이터 여부 등)

#### (5) 관계 반정규화(중복관계 추가)

- JOIN이 필요한 경우가 많을 때

---

### 3. 트랜잭션(Transaction)

- 데이터를 조작하기 위한 하나의 논리적인 작업 단위
- (ex) 이벤트 응모 저장 -> 쿠폰 발생
- 하나라도 실패하면 전체 실행을 취소(롤백)해야함

#### (1) 특징

- 원자성 : 더이상 분리할 수 없는 업무의 최소단위, 전부 처리되거나 하나도 처리되지 않아야함
- 일관성 : 하나의 트랜잭션이 완료된 후에 DB는 일관된 상태(모순되지 않은)여야함 (ex) 상품의 재고와 판매 전체 총 합은 같아야 함
- 고립성 : 실행 중인 트랜잭션의 중간 결과에 다른 트랜잭션이 접근할 수 없음
- 지속성 : 트랜잭션이 성공적으로 실행 완료되면 결과는 DB에 영속적을 저장됨

---

### 4. NULL

- 존재하지 않음, 값이 없음
- 0과 다름
- 가로 연산 : NULL이 포함되면 NULL
- 세로 연산 : NULL은 제외하고 연산

---

---

# PART2. SQL 기본 및 활용

## CHAPTER3. 관리 구문

### 1. DDL (Data Definition Language)

#### (1) CREATE

```sql
CREATE TABLE TB(
  C1 데이터 타입(DEFAULT/ NULL여부)
)

CREATE TABLE TB(
  C1 NUMBER NOT NULL,
  C2 VARCHAR(20)
  CONSTRAINT PK PRIMARY KEY (C1)
  CONSTRAINT FK PRIMARY KEY (C2) REFERENCES TB2(C2)
)

-- 테이블 복사
CREATE TB AS SELECT * FROM 원본테이블;
```

- 테이블 생성
- 데이터 타입
  - 문자 : CHAR(고정), VARCHAR(가변, 스페이스바를 문자로 취급), CLOB
  - 숫자 : NUMBER
  - 날짜 : DATE
- 규칙
  - 테이블명 고유
  - 한 테이블 내에서는 컬럼명 고유
  - 컬럼명 뒤 데이터 유형과 크기 명시
  - 컬럼 정의는 괄호 안에
  - 테이블명과 컬럼명은 숫자로 시작 X
  - 마지막은 세미콜론으로 끝
- CONSTRAINT : 제약조건 정의
  - PRIMARY KEY(기본키) : 고유성을 보장하고 NULL 불가능
  - UNIQUE KEY(고유키) : 고유성을 보장하지만 NULL가능
  - NOT NULL
  - CHECK() : 컬럼에 저장될 수 있는 값의 범위 (ex) CHECK(C1 IN ('A','B')) C1는 A 또는 B만 가능
  - FOREIGN KEY(외래키)
    - 참조 무결정 규정 옵션 선택 가능
    1. CASCADE : PARENT값 삭제 시 CHILD값 같이 삭제
    2. SET NULL : PARENT값 삭제 시 CHILD의 해당 컬럼 NULL처리
    3. SET DEFAULT : PARENT값 삭제 시 CHILD의 해당 컬럼 DEFAULT 값으로 변경
    4. RESTRICT : CHILD 테이블에 해당 데이터가 PK로 존재하지 않는 경우에만 PARENT값 삭제 및 수정 가능
    5. NO ACTION : 참조 무결성이 걸려있는 경우 삭제 및 수정 불가
- 테이블을 복사할 경우 NOT NULL조건만 복사되고 나머지 제약조건은 초기화됨

#### (2) ALTER

```sql
ALTER TABLE TB ADD C1 DATATYPE

ALTER TABLE TB DROP COLUMN C1

ALTER TABLE TB MODIFY (C1 DATATYPE [DEFAULT값] [NOT NULL],,,)

ALTER TABLE TB RENAME COLUMN 기존컬럼 TO 변경할 컬럼

ALTER TABLE TB ADD CONSTRAINT 제약조건명 제약조건(C1)
```

- 테이블 구조를 변경하는 경우 사용
- ADD : 컬럼 추가, 맨 끝에 위치함(위치 지정 X)
- DROP COLUMN : 기존 컬럼 삭제, 복구 X
- MODIFY : 컬럼을 변경, 컬럼에 저장된 모든 데이터가 새로 지정한 크기보다 작아야함, 컬럼에 저장된 데이터가 없는 경우만 유형 변경 가능, NULL이 없을 경우에만 NOT NULL 추가 가능
- RENAME COLUMN(컬럼 이름 변경), ADD CONSTRAINT(제약조건 추가)

#### (3) DROP

```sql
DROP TABLE TB [CASCADE CONSTRAINT];
```

- 테이블을 삭제할 때 쓰는 명령어
- 해당 테이블이 참조하고 있는 다른 테이블이 존재하는 경우 CASCADE 옵션을 명시하지 않으면 삭제되지 않음
- CASCADE CONSTRAINT : 참조 제약조건도 함께 삭제한다는 의미

#### (4) RENAME

```sql
RENAME A TO B
```

#### (5) TRUNCATE

```sql
TRUNCATE TABLE TB
```

- 테이블에 저장되어 있는 데이터를 모두 제거하는 명령어

---

### 2. DML (Data Manipulation Language)

- DDL에서 정의한 대로 데이터를 입력하고, 입력된 데이터를 수정, 삭제, 조회하는 명령

#### (1) INSERT

```sql
INSERT INTO TB (C1,C2) VALUES(DATA1,DATA2) -- C1속성에 DATA1, C2속성에 DATA2

INSERT INTO TB VALUES(전체 컬럼에 입력될 데이터 리스트)
```

- 데이터 입력 명령어
- 명시되지 않은 컬럼에는 NULL값이 입력됨 (PK, NOT NULL 제약조건 주의)
- 리스트로 입력할 경우, 순서와 전체 컬럼수에 맞춰야함

#### (2) UPDATE

```sql
UPDATE TB SET C1=D1 (WHERE 조건)
```

- 이미 저장된 데이터를 수정하는 명령어
- WHERE절이 없으면 테이블의 모든 Row가 변경됨
- SET 구분='경력' 와 같이 표현
- SET COL1=COL2+COL3 와 같은 연산도 가능

#### (3) DELETE

```sql
DELETE FROM TB (WHERE 조건)
```

- 저장된 데이터를 삭제하고 싶을때 사용하는 명령어
- WHERE절이 없으면 테이블의 모든 ROW가 삭제됨
- 데이터 삭제 명령어 비교
  1. TRUNCATE : 전체 초기화
     - ROLLBACK 대부분 불가능
     - 완전히 삭제할 경우는 TRUNCATE가 부하 측면에서 유리
     - WHERE 불가능
     - 테이블 구조 유지
  2. DROP : 테이블 폐기
     - ROLLBACK 불가능
     - WHERE 불가능
     - 테이블 구조도 사라짐
  3. DELETE : 조건별 데이터 삭제
     - ROLLBACK 가능
     - WHERE 가능
     - 테이블 구조 유지

#### (4) MERGE

```sql
MERGE
  INTO 타겟 테이블
  USING 비교 테이블 -- 특정 조건의 데이터만 가능 (SELECT문으로 가능)
    ON 조건 -- (A.ID=B.ID)
  WHEN MATCHED THEN
      UPDATE
        SET C1=새로운 데이터 [,C2=새로운 데이터,,,]
  WHEN NOT MATCHED THEN
      INSERT [(C1,C2,,,)]
      VALUES (D1,D2,,,)
```

- 테이블에 새로운 데이터를 입력하거나 이미 저장되어 있는 데이터에 대한 변경 작업을 한번에 할 수 있도록 해주는 명령어
- WHEN MATCHED THEN : 조건에 맞는 데이터가 있으면 ~
- WHEN NOT MATCHED THEN : 조건에 맞는 데이터가 없으면 그 데이터를 ~

---

### 3. TCL (Transaction Control Language)

#### (1) COMMIT

- INSERT, DELETE, UPDATE 후 변경된 내용을 확정, 반영하는 명령어
- COMMIT을 실행하지 않으면 메모리에만 반영 -> 메모리는 휘발성이며 다른 사용자는 조회 X
- COMMIT을 실행해야 최종적으로 데이터 파일에 기록되고 트랜잭션이 완료됨
- UPDATE한 뒤, 오랜 시간 동안 COMMIT이나 ROLLBACK을 하지 않으면 LOCK

#### (2) ROLLBACK

- INSERT, DELETE, UPDATE 후 변경된 내용을 취소하는 명령어
- 변경하기 이전 값으로 복구
- UPDATE한 뒤, 오랜 시간 동안 COMMIT이나 ROLLBACK을 하지 않으면 LOCK

#### (3) SAVEPOINT

- ROLLACK을 수행할 때 일부만 되돌릴 수 있게 하는 명령어

```sql
...
SAVEPOINT A;
...
ROLLBACK TO A
```

---

### 4. DDL (Data Definition Language)

- USER를 생성하고 데이터 컨트롤 권한을 관리하는 명령어

#### (1) USER

```sql
CREATE USER A IDENTIFIED BY PWD;

ALTER USER A IDENTIFIED BY PWD;

DROP USER A;
```

#### (2) GRANT

```sql
GRANT 권한 TO A;

REVOKE 권한 FROM A;
```

- 권한
  - CREATE SESSION
  - CREATE USER
  - CREATE TABLE

#### (3) ROLE

- 특정 권한들을 하나의 세트로 묶어서 부여하는 것

```sql
CREATE ROLE R1;

GRANT 권한 TO R1;

GRANT R1 TO A;
```
