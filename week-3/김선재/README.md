**다시 보면 좋을 개념**

- 모델링의 3가지 관점
  1. 데이터 관점 : 어떤 데이터가 업무와 얽히는지, 데이터 간의 관계 모델링 -> 설계 시작으로 엔터티를 도출하고 관계를 맺는 과정을 떠올림
  2. 프로세스 관점 : 업무가 실제로 처리하고 있는 일은 무엇인지 또는 앞으로 처리해야 하는 일은 무엇인지를 모델링 -> 본질적인 문제를 해결하고자 하는 과정을 떠올림
  3. 데이터와 프로세스의 상관 관점 : 프로세스의 흐름에 따라 데이터가 어떤 영향을 받는지를 모델링 -> 앞에서 칠판으로 프로세스에 따라 데이터 상태 등을 변경하는과정을 떠올림
- 모델링의 3가지 단계
  1. 개념적
  2. 논리적
  3. 물리적
- 데이터의 독립성 - ANSI-SPARC
  - 외부 스키마 : 사용자 관점 -> 각 사용자가 보는 데이터베이스의 스키마를 정의
  - 개념 스키마 : 통합된 관점 -> 모든 사용자가 보는 데이터베이스의 스키마를 통합, 데이터를 표현하고 데이터 간의 관계를 나타냄
  - 내부 스키마 : 물리적인 관점 -> 실질적인 데이터의 저장 구조나 컬럼 정의, 인덱스 등이 포함
- ERD 표기법
  - `Peter Chen` : 사각형으로 엔터티, 마름모로 행위 표현
  - `IE/Crow's Foot` : 까마귀발 표기법 -> 일대다 관계에서 M에 속하는 엔터티에 까마귀발을 그려 놓음
  - `1DEF1X` : 사각형으로 엔터티, 관계 표현시 빈 마름모, 점선, 까만 원으로 표시
  - `Barker` : 선을 반으로 나눠, 점선, 실선으로 만들 수 있다. `0..N` 으로 관계 표시
  - `UML` : 소프트웨어 공학에서 주로 사용되며, 1, 0..N 으로 관계 표시
- 엔터티의 특징
  - 업무에 쓰이는 정보
  - 유니크함을 보장할 수 있는 식별자가 있어야 함
  - 2개 이상의 인스턴스를 가지고 있어야 함 : 1개는 엔터티로 만들 필요가 없음
  - 반드시 속성을 가지고 있어야 함 : 반드시 자신을 상세하게 나타낼 수 있는 속성을 가지고 있어야 함
- 다른 엔터티와 1개 이상의 관계를 가지고 있어야 함
  - 각 엔터티는 다른 엔터티와의 연관성을 가지고 있어야 한다.
- 엔터티의 분류
  - 유형 / 무형
    - 유형 : 안정/지속적
      - ex. 상품, 회원
    - 개념 : 형태 없음
      - ex. 부서, 학과
    - 사건 : 행위
      - ex. 주문, 이벤트 응모
  - 발생 시점
    - 기본 엔터티 : 원래 업무에 존재, 독립적, 자식 엔터티 보유 가능
      - ex. 상품, 회원, 부서
    - 중심 엔터티 : 기본 엔터티에서 파생 + 행위 엔터티 생성, 업무에 있어서 중심적인 역할을 하며 데이터의 양이 많이 발생
      - ex. 주문, 매출, 계약 등
    - 행위 엔터티 : 2개 이상의 엔터티에서 파생 / 데이터가 자주 변경되거나 증가할 수 있음
      - ex. 주문 내역, 이벤트 응모 이력
- 속성의 분류
  - 특성에 따른 분류
    - 기본속성 : 업무 프로세스 분석으로 바로 정의 가능한 속성
      - ex. 상품이름, 주민등록번호, 상품가격
    - 설계속성 : 업무에 없지만, 설계하다 보니 필요하다고 판단되어 도출해낸 속성
      - ex. 고유번호
    - 파생속성 : 다른 속성값을 계산하거나, 특정한 규칙으로 변형되어 생성한 속성
      - ex. 이벤트 응모건수
  - 구성방식에 따른 분류
    - PK 속성 : 엔터티의 인스턴스들을 식별할 수 있는 속성
      - ex. 회원번호
    - FK 속성 : 다른 엔터티의 속성에서 가져온 속성
      - ex. 회원등급코드
    - 일반 속성 : PK / FK 빼고 나머지
      - ex. 아이디, 회원명, 핸드폰번호
- 도메인 : 속성이 가질 수 있는 속성값의 범위 - ex. 우편번호는 다섯 자리의 숫자의 범위를 가짐
- 용어사전 : 속성명은 업무와 직결되는 항목. 속성의 이름을 정확하면서도 직관적으로 부여, 용어의 혼란을 없애기 위해 용어사전이라는 업무사전을 사용
  - 실사례 혼용 사례 : 개발 서버, 데브 서버, 테스트 서버 / 구독, 플랜, 정기결제, 정기구독
- 시스템 카탈로그 : 사용자 테이블과 별개로 시스템 자체에 관련이 있는 데이터를 담고 있음. SQL로 조회만 가능하고 CUD 쿼리는 불가능
- 주식별자 : 유일성 (인스턴스마다 유니크함을 부여해 식별) / 최소성 (유일성 보장하는 최소 개수) / 불변성 / 존재성 (NULL 일 수 없음)
- 식별자 분류
  - 대표성 여부
    - 주식별자 : 유일성, 최소성, 불변성, 존재성을 가진 대표 식별자, 다른 엔터티와 참조 관계로 연결
    - 보조식별자 : 인스턴스 식별 But 대표 식별자는 아님, 다른 엔터티와 참조 관계로 연결되지 않음
  - 스스로 생성여부
    - 내부식별자 : 엔터티 내부에서 스스로 생성된 식별자
    - 외부식별자 : 다른 엔터티에서 온 식별자, 연결고리
  - 단일 속성 여부
    - 단일식별자 : 하나의 속성으로 구성
    - 복합식별자 : 두 개 이상의 속성으로 구성
  - 대체 여부
    - 본질식별자 : 업무 프로세스에 존재하는 식별자, 가공되지 않은 원래의 식별자, 원조식별자
    - 인조식별자 : 대리식별자 - 주식별자 속성이 두 개 이상을 하나로 묶어서 사용
- 정규화
  - 제1정규형 : 모든 속성은 반드시 하나의 값만 가져야 한다.
    - `배우, 가수, 작곡가` 처럼 여러 값이 있으면 위배. 사용 시에 split 처리를 하는 등의 사용측에서 별도 가공이 필요 (DB 단에서 처리하기 부담)
  - 제2정규형 : 반드시 모든 주식별자에 모든 일반 속성이 종속되어야 한다. 주식별자가 단일식별자가 아닌 복합식별자인 경우, 주식별자의 일부에만 일반 속성이 종속될 수 있음
    - (주문번호, 음료코드), 주문수량, 음료명 -> 음료명(일반속성)이 음료코드(주식별자 일부)에만 종속되어 위배
    - `입력 이상 현상` : 주문되지 않은 음료는 입력불가능한 현상
    - `수정 이상 현상` : 음료명이 변경되면, 모든 주문 데이터가 변경되는 현상
    - (보충) `삭제 이상 현상` : 주문을 삭제하면, 음료 정보까지도 삭제되는 현상
  - 제3정규형 : 주식별자가 아닌 모든 속성 간에는 서로 종속될 수 없음
    - (일련번호), 이름, 생년월일, 소속사코드, 소속사명 : 소속사명 (일반속성)이 소속사코드(일반속성)에 종속되어 위배
    - 따라서 종속되는 일반속성끼리 따로 테이블 분리
- 반정규화 : 정규화 이후에 성능이 느려질 시 고려하고 진행되어야 함
  - 테이블 병합 : 1:1 / 1:M(중복 데이터 생김, 1쪽 속성이 적으면 유리) / 슈퍼 서브 타입 테이블 병합
  - 테이블 분할 : 테이블 수직 분할 (속성 분할, 자주 사용하는 속성이 아니거나 대부분의 인스턴스가 해당 속성값을 NULL 일때 고려) / 테이블 수평 분할(인스턴스 분할, 파티셔닝, 년도별로 분리 가능)
  - 테이블 추가 : 중복 / 통계(미리 계산하여 별도 테이블에 저장) / 이력(과거 데이터 관리) / 부분(특정 업무에만 쓰이는 부분만 중복으로 테이블 추가하여 관리)
- 트랜잭션 : ACID
  - 원자성 (Atomicity) : 더이상 분리가 불가능한 업무의 최소단위. 전부 처리 / 전부 취소
  - 일관성(Consistency) : 완료된 후에도 일관된 상태여야 함 / 여러 제약 조건(기본키, 외래키, 비즈니스룰) 준수하는 상태여야 함. 음수가 될 수 없다인데, 음수가 되어있으면 안됨
  - 고립성(Isolation) : 실행 중인 트랜잭션의 중간 결과에 다른 트랜잭션이 접근할 수 없음
  - 지속성(Durability) : 성공적으로 완료하면 데이터베이스에 영속적으로 저장됨
- TRUNCATE : 트랜잭션 롤백을 위한 Undo Log 를 남기지 않은 채로, 삭제 처리할 수 있어 성능에 유리
- MERGE : 새로운 데이터를 입력하거나, 이미 저장되어 있는 데이터에 대한 변경 작업을 한 번에 할 수 있도록 함
  - USING 비교 테이블명 ON 조건
  - WHEN MATCHED THEN (쿼리) / WHEN NOT MATCHED THEN (쿼리)
- TCL : COMMIT / ROLLBACK / SAVEPOINT
- DDL : CHAR / VARCHAR -> CHAR 은 고정 크기로 빈 공간은 공백으로 채워짐
- 제약 조건 : PRIMARY KEY(기본 키) / UNIQUE KEY(고유키) / NOT NULL / CHECK(DEL_YN IN (’Y”, ‘N’)) 으로 제한 / FOREIGN KEY(외래 키)
  - CASCADE : 부모 삭제시 자식도 같이 삭제
  - SET NULL : 부모 삭제시 자식은 Null 처리
  - SET DEFAULT : 부모 삭제시 자식은 Default 칼럼값
  - RESTRICT : 자식에 없을 때만 부모 삭제 가능
  - **NO ACTION : 참조 무결성 제약이 있으면, 수정 및 삭제 불가**
- `CREATE USER 사용자명 IDENTIFIED BY 패스워드` / `ALTER USER 사용자명 IDENTIFIED BY 패스워드` / `DROP USER 사용자명`
- `GRANT CREATE SESSION TO USER - 추가` / `REVOKE CREATE SESSION TO USER - 삭제`
- `CREATE ROLE 롤명` / `GRANT 권한 TO 롤명` / `GRANT 롤명 TO 사용자명`

**문제를 풀며 알게 된 팁**

- 1장은 개념 / 속성 / 분류 위주로 많이 물어보니 키워드 암기 필수

**데이터 모델링 지양해야 할 점**

1. 중복(Duplication) : 같은 데이터가 여러 엔터티에 중복으로 저장되는 현상을 지양
2. 비유연성(Inflexibility) : 데이터 모델의 설계에 따라 애플리케이션의 사소한 변경에도 데이터 모델이 수시로 변경될 수 있다. 유지보수에 어려움을 가하므로, 데이터 모델과 프로세스를 분리해 유연성을 높여야 한다.
3. 비일관성 : 중복이 없는 경우에도 발생할 수 있다. 다른 데이터와의 연관성을 고려하지 않고, 일부 데이터만 변경할 수 있기 때문이다. 데이터 모델링을 할 때, 데이터 간의 연관 관계에 대해 명확하게 정의해야 한다.

**ERD 작성 순서**

1. 그린다.
2. 배치한다.
3. 관계를 나타낸다.
4. 관계명을 쓴다.
5. 참여도를 나타낸다. -> ex. 양 끝에 1:N Crow 를 그린다. 해시(|)마크와 까마귀 발 기호 사용 `| ------ <`
6. 필수 여부를 나타낸다. -> ex. ㅣ(필수), O(선택) 를 그린다. `| | ----- O <`

**속성 의미**

- 속성 : 의미상 분리되지 않는 최소의 데이터 레벨로 프로세스에 필요한 항목

* 중복 관계 추가 : 데이터의 무결성을 깨뜨릴 위험성 없이 데이터 처리의 성능을 향상시킬 수 있는 반정규화 기법

**공유하고 싶은 내용**

- NO ACTION : 아무것도 안하는 행위인줄 알고 있었는데, 수정 및 삭제가 불가능하도록 가장 강하게 막아주는 의미였네요.
- 제1~3정규형은 사례 위주로 이해하며 넘어가기 - 부분함수 종속 / 이행함수 종속은 까먹기 딱 좋다.
  - 보이스-코드(BCNF) : 제3정규형 만족 + 릴레이션의 모든 결정자가 후보키가 되도록 하는 정규형 / 결정자가 후보키가 아닌 속성 제거
  - 제4정규형 : BCNF 만족 + 두 속성이 1:N 대응이 되는 다치 종속 관계를 제거 (다중 중속값)
    - 수업 / 교재 / 강사 릴레이션에서 한 수업에 교재가 하나 추가되면, 강사들에 맞게 레코드를 추가해야 한다.
    - 수업 ->> 교재, 수업 ->> 강사 다치 종속 관계가 존재 ( 데이터 중복 )

```
Teaching database
수업	교재	강사
AHA	Silberschatz	John D
AHA	Nederpelt	William M
AHA	Silberschatz	William M
AHA	Nederpelt	John D

AHA	Silberschatz	Christian G
AHA	Nederpelt	Christian G
OSO	Silberschatz	John D
OSO	Silberschatz	William M
```

```
R을 릴레이션 스키마라고 하자. ⍺ ⊆ R 이고 β ⊆ R 라 하자. 만약 어떤 릴레이션 r(R)에 대해, t1[⍺] = t2[⍺] 인 r 안의 모든 튜플의 쌍 t1과 t2에 대해, r안에 다음과 같은 식이 성립하는 t3 and t4 가 존재하면,

t1[⍺] = t2[⍺] = t3[⍺] = t4[⍺]  <-- t1, t2, t3, t4 는 튜플이며, 레코드에 해당.즉 첫 번째 행의 a 칼럼, 두 번째 행의 a 칼럼으로, 위 예시에서 AHA 와 동일

t3[β] = t1[β] <- 1, 3번째 행의 두 번째 칼럼 Silberschatz 동일
t3[R-β] = t2[R-β] <- r(R) 은 릴레이션, 3번째 행과 2번째 행에서 두 번째 칼럼을 제외한 모든 칼럼의 값이 동일 (AHA / William M)

t4[β] = t2[β] <- 2, 4번째 행의 두 번째 칼럼 값이 Nederpelt 같음
t4[R-β] = t1[R-β] <- 4, 1번째 행의 두 번째 칼럼을 제외한 모든 칼럼의 값이 동일 ( AHA / John D)

다치 종속 a->>B 가 R에 대해 성립한다.
```

- 제5정규형 : 후보키(각 행을 유일하게 식별할 수 있는 최소한의 속성들)를 통하지 않은 조인종속을 제거
- 업무에서 배치 재시도로 멱등성을 유지하고플 때, `INSERT INTO ~ ON DUPLICATE KEY UPDATE` 으로 해결했습니다.

- TRUNCATE SQL이 빠른 이유는?
  1. **데이터 처리 방식 차이** : 데이터 페이지(2의 제곱 KB, 16KB, 32KB, ...) 단위로 작업을 수행한다. 저장된 페이지 할당을 한 번에 취소한다. 개별 행을 스캔하고 처리하는 단계가 없다. `DELETE`는 행을 하나씩 삭제하므로, 행마다 처리 과정이 필요하다.
  2. **트랜잭션 로그 사용 최소화** : 데이터 페이지 할당 취소만을 트랜잭션 로그에 기록한다. `DELETE`는 삭제하는 모든 행에 트랜잭션 로그를 생성한다. 로그 작업이 줄어들어, 디스크 I/O와 로그 처리 부담이 감소한다.
  3. **저장 공간 즉시 해제** : 저장 공간(스토리지)까지 원래대로 돌려놓아 `CREATE TABLE` 상태로 원복시킨다. `DELETE`는 데이터만 삭제하고 저장 공간은 그대로 유지한다. 저장 공간이 즉시 해제되므로 추가 작업이 필요 없다.
  - `TRUNCATE`
    - 테이블 초기화
    - 데이터 페이지 할당 해제 : 모든 데이터 페이지를 운영체제에 반환
    - HWM(High Water Mark) 초기화 : 테이블의 최대 사용 공간 표시를 초기화
    - 시스템 카탈로그 업데이트 : 테이블 통계가 즉시 0으로 업데이트
  - `DELETE`
    - 논리적 삭제만 수행 : 페이지 블록 내에서 삭제되나 오프셋은 변경되지 않는다. 페이지 블록내의 해당 공간은 '삭제됨' 또는 '사용 가능' 마크만 된다. 따라서 오프셋을 초기화하려면, 파편화 문제를 해결해야 한다.
      - 파편화 전략 (정확히 맞는 크기, 처음으로 맞는 크기, 빈 공간이 최소화되는 크기) 등으로 빈 블록에 새 행이 삽입된다.
    - HWM 유지 : 최대 사용 공간 표시가 변경되지 않는다.
    - 재사용 가능한 공간 : 삭제된 행의 공간은 새 데이터 삽입 시 재사용 가능하다.
    - 롤백 가능성 : 트랜잭션 로그에 기록되어 롤백이 가능하다.
  4. **인덱스 처리 방식** : 인덱스 페이지도 함께 제거합니다. 인덱스 재구성이 필요 없다. `DELETE`는 인덱스 엔트리를 하나씩 제거해야 하므로, 인덱스 관련 비용이 더 많이 발생한다.
  5. **스캔 작업 생략** : 데이터 스캔 작업을 수행하지 않고, 전체 데이터를 바로 제거한다. `DELETE`는 조건절이 없더라도 내부적으로 모든 행을 스캔해야 한다.
  6. **자동 커밋 특성** : `DDL`로 분류되어 자동 커밋하고 실행 즉시 완료한다.
