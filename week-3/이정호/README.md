# PART 3 | CHAPTER 3 관리구문

## 1) DML

Data Manipulation Language란 의미로 DDL에서 정의한 대로 데이터를 입력하고, 입력된 데이터를 수정/삭제/조회하는 명령어 이다.

### (1) INSERT

> INSERT INTO 테이블명 (컬럼명1, 컬럼명2, …) VALUES (데이터1, 테이터2, …);
> 
- 명시되지 않은 컬럼에는 NULL값이 입력된다. NOT NULL 제약 조건의 컬럼인 경우 입력 안됨.

> INSERT INTO 테이블명 VALUES (전체 컬럼에 입력될 데이터 리스트);
> 

### (2) UPDATE

> UPDATE 테이블명 SET 컬럼명 = 새로운 데이터 (WHERE 수정할 데이터에 대한 조건);
> 
- UPDATE 입사 SET 구분 = ‘경력’ WHERE 입사자사번 = ‘123’;
- 수정하고자 하는 컬럼이 많다면 SET절에 콤마로 이어서 명시 가능
- WHERE 절이 없으면 모든 Row가 변경

### (3) DELETE

> DELETE FROM 테이블명 (WHERE 삭제할 데이터에 대한 조건);
> 
- WHERE 절이 없으면 모든 Row가 삭제
- 롤백이 불가능한 TRUNCATE를 쓰는게 시스템 부하 측면에서 유리하다

### (4) MERGE

테이블에 새로운 데이터를 입력하거나 이미 저장되어 있는 데이터에 대한 변경작업을 한 번에 할 수 있다

MERGE를 이용하여 백업하는 예시

> MERGE
  INTO DEPARTMENTS_BU DB
  USING DEPARTGMENTS D
    ON (DB.DEPARTMENT_ID = D.DEPARTMENT_ID)
  WHEN MATCHED THEN
             UPDATE
                    SET DB.DEPARTMENT_NAME = D.DEPARTMENT_NAME
  WHEN NOT MATHED THEN
             INSERT (DB.DEPARTMENT_ID, DB.DEPARTMENT_NAME) 
             VALUES (D.DEPARTMENT_ID, D.DEPARTMENT_NAME)
> 
- USING (SELECT * FROM DEPARTMENTS WHRER MANAGER_ID IS NOT NULL) D
    - 이를 이용하면 특정 조건의 데이터들만 백업가능

## 2) TCL

Transaction Control Language라는 의미로 트랜잭션을 제어하는 명령어이다.

### (1) 트랜잭션의 특징

- 원자성: 트랜잭선으로 묶인 일련의 동작들을 모두 성공하거나 모두 실패해야 한다.
- 일관성: 트랜잭션 완료 후에도 데이터베이스가 가진 데이터에 일관성이 있어야 한다.
- 고립성: 하나의 트랜잭션은 고립되어 수행되어야 한다.
- 지속성:

### (2) COMMIT

- INSERT/DELETE/UPDATE 후 변경된 내용을 확정, 반영하는 명령어이다.
- COMMIT을 싱행하지 않으면 메모리 까지만 반영되므로, COMMIT을 실행해야 최종적으로 데이터파일에 기록이 된다.
- UPDATE한 뒤 오랜시간동안 COMMIT이다 ROLLBACK을 하지 않았을 경우 Lock에 걸려서 다른 사용자가 변경할 수 없는 상황이 발생할 수 있으니 주의해야 한다.

### (3) ROLLBACK

- INSERT/DELETE/UPDATE 후 변경된 내용을 취소하는 명령어이다.

### (4) SAVEPOINT

- ROLLBACK을 수행할 때 전체 작업을 되돌리지 않고 일부만 되돌릴 수 있게 하는 기능을 가진 명령어이다.
- ROLLBACK 뒤에 특정 SAVEPOINT를 지정해주면 그 지점까지만 데이터가 복구된다.

## 3) DDL

Data Definition Language란 의미로 데이터를 정의하는 명령어이다.

- CHAR 타입에서는 공백을 문자로 친다. ‘Jennie’ = ‘Jennie ‘

### (1) CREATE

> CREATE TABLE 테이블명 (
    컬럼명1 데이터 타입 (DEFAULT / NULL duqn),
    …
);
> 
- NULL: 공백(’ ‘)과는 다르며 존재하지 않는 값이란 의미
- 규칙(생소한 것들만 정리함)
    - 컬럼명 뒤에 데이터 유형과 데이터 크기가 명시되어야 한다.
    - 테이블명과 컬럼명은 숫자로 시작될 수 없다.
- CONSTRAINT(제약조건)도 함꼐 정의해줄 수 있다.
    - 제약조건의 종류 - 356p
- 기존의 테이블을 복사해서 생성하고 싶은 경우
    - CREATE 테이블명 AS SELECT * FROM 복사할 테이블명;
    - 제약조건의 백 퍼센트가 복사되는 것은 아니고 NOT NULL 조건만 되며 다른 제약조건은 초기화된다. 필요시 별도로 ALTER 명령어를 써서 정의해주어야 한다.

### (2) ALTER

테이블 정의 변경시 사용한다

- ADD COLUMN
    
    > ALTER TABLE 테이블명 ADD 컬럼명 데이터 유형;
    > 
    - 추가된 컬럼의 위치는 늘 맨 끝이 되며 별도로 위치를 지정해줄 수 없다.
- DROP COLUMN
    
    > ALTER TABLE 테이블명 DROP COLULMN 컬럼명;
    > 
    - 한번 삭제한 컬럼은 복구할 수 없다.
- MODIFY COLUMN
    
    > ALTER TABLE 테이블명 MODIFY (컬럼명1 데이터 유형[DEFAULT 값] [NOT NULL], … ;
    > 
    - 컬럼에 저장된 모든 데이터의 크기가 줄이고자 하는 컬럼의 크기가 작을 경우에만 줄일수 있다.
    - 컬럼에 저장된 데이터가 없는 경우에만 데이터 유형을 변경할 수 있다.
    - DEFAULT값 변경시에는 변경이후 저장되는 데이터에만 적용
    - 현재 NULL 값이 저장되어 있지 않은 컬럼에만 NOT NULL 제약조건 추가가 가능
- RENAME COLUMN
    
    > ALTER TABLE 테이블명 RENAME COLUMN 기존 컬럼명 TO 변경할 컬럼명;
    > 
- ADD CONSTRAINT
    
    > ALTER TABLE 테이블명 ADD CONSTRAINT 제약조검명 제약조건 (컬럼명);
    > 

### (3) DROP TABLE

테이블을 삭제할 때 쓰는 명령어이다.

- 테이블을 참조하고 있는 다른 테이블이 존재하는 경우 CASCADE 옵션을 명시하지 않으면 삭제되지 않는다.
- CASCADE CONSTRAINT는 참조 제약조건도 함께 삭제한다는 의미이다.

> DROP TABLE 테이블명 [CASCADE CONSTRAINT];
> 

### (4) RENAME TABLE

> RENAME 기존 테이블명 TO 변경할 테이블명;
> 

### (5) TRUNCATE TABLE

> TRUNCATE TABLE 테이블명;
> 
- DELETE와 유사하지만 저장 공간이 재사용되도록 초기화된다는 차이점이 있다.
- ROLLBACK이 불가능해 DDL로 분류된다.(DELETE 는 DML)

## 4) DCL

Data Control Language란 의미로 USER를 생성하고, USER에게 데이터를 컨트롤할 수 있는 권한을 부여하거나 회수하는 명령어이다.

### (1) USER 관련 명령어

하나의 DATABASE는 여러 개의 USER를 가질 수 있다.

- CREATE USER
    
    > CREAETE USER 사용자명 IDENTIFIED BY 패스워드;
    > 
- ALTER USER
    
    > ALTER USER 사용자명 IDENTIFIED BY 패스워드;
    > 
- DROP USER
    
    > DROP USER 사용자명;
    > 

### (2) 권한 관련 명령어

- GRANT(권한 부여)
    
    > GRANT 권한 TO 사용자명;
    > 
- REVOKE(권한 회수)
    
    > REVOKE 권한 FROM 사용자명;
    > 

### (3) ROLE 관련 명령어

ROLE이란 특정 권한들을 하나의 세트처럼 묶는 것이다.

ROLE을 이용한 권한 부여

1. ROLE을 생성한다.
    
    > CREATE ROLE 롤명;
    > 
2. ROLE에 권한을 부여한다.
    
    > GRANT 권한 TO 롤명;
    > 
3. ROLE을 사용자에게 부여한다.
    
    > GRANT 롤명 TO 사용자명;
    > 

## 적중예상문제

---

# PART 1 | CHAPTER 1 데이터 모델링의 이해

## 1) 데이터 모델의 이해

### (1) 모델링이란?

모델링이 갖춰야 할 조건

- 현실 세계를 반영해야 한다.
- 단순화하여 표현해야 한다.
- 관리하고자 하는 데이터를 모델로 설계한다.

### (2) 모델링의 특징

- 추상화: 현실 세계를 일정한 형식으로 표현하는 것.
- 단순화: 복잡한 현실 세계를 정해진 표기법으로 단순하고 쉽게 표현한다는 의미히다.
- 명확화: 불문명함을 제거하고 명확하게 해석할 수 있도록 기술한다는 의미이다.

### (3) 모델링의 세 가지 관점

- 데이터 관점
- 프로세스 관점
- 데이터와 프로세스의 상관 관점

### (4) 모델링의 세 가지 단계

1. 개념적 데이터 모델링: 업무 중심적이고 포괄적인 수준의 모델링
2. 논리적 데이터 모델링: key, 속성, 관계 등을 모두 표현하는 단계
3. 물리적 데이터 모델링: 성능이나 가용성 등의 물리적인 성격을 고려하여 모델을 표현하는 단계이다.

### (5) 데이터의 독립성

3단게 구조로 나누는 이유는 데이터베이스에 대한 사용자들의 관점과 데이터베이스가 실제로 표현되는 물리적인 방식을 분리하여 독립성을 보장하기 위함이다.

- 3단계 스키마 구조
    1. 외부 스키마: 사용자의 관점(View) 단계로 여러 개의 사용자 관점으로 데이터베이스의 스키마를 정의한다.
    2. 개념 스키마: 통합된 관점 단계로 모든 사용자가 보는 데이터베이스의 스크마를 통합하여 전체 데이터베이스를 나타내는 것이다. 저장되는 데이터들을 표현하고 데이터들 간의 관계를 나타낸다.
    3. 내부 스키마: 물리적인 관점 단계로 물리적인 저장 구조를 나타낸다.  실질적인 데이터의 저장 구조나 컬럼 정의 인덱스 등이 포함된다.
- 3단계 스키마 구조가 보장하는 독립성
    - 논리적 독립성: 개념 스키마가 변경되어도 외부 스키마는 영향받지 않는다.
    - 물리적 독립성: 내부 스키마가 변경되어도 외부/개념 스키마는 영향받지 않는다.

### (6) ERD(Entity Relationship Diagram)

시스템에 어떤 엔터티들이 존재하며 그들 간에 어떤 관계가 있는지를 나타내는 다이어그램이다.

- ERD 표기 방식 - 9p
- IE/Crow’s Foot 표기법 - 10p
    - 가장 많이 사용한다

## 2) 엔터티(Entity)

데이터베이스 내에서 식별 가능한 객체

- 엔터티: Table. 인스턴스: Row, 속성: Column
- 엔터티의 특징
    - 업무에서 쓰이는 정보여야 함
    - 유니크함을 보장할 수 있는 식별자가 있어야 함
    - 2개 이상의 인스턴스를 가지고 있어야 함
    - 반드시 속성을 가지고 있어야 함
    - 다른 엔터티와 1개 이상의 관계를 가지고 있어야 함
- 엔터티의 분류
    - 기본 엔터티: 업무에 원래 존재하는 정보
        - 독립적으로 생성되며 자식 엔터티를 가질 수 있다
        - 상품, 회원, 부서
    - 중심 엔터티: 기본 엔터티로 부터 파생되고, 행위 엔터티 생성
        - 업무에 있어서 중심적인 역할을 하며 데이터의 양이 많이 발생
        - 주문, 매출, 계약
    - 행위 엔터티: 2개 이상의 엔터티로 부터 파생
        - 데이터가 자주 변경되거나 증가할 수 있다
        - 주문 내역, 이벤트 응모 이력등
- 엔터티 이름을 정할 때 주의할 점
    - 한글은 약어를 쓰지 않고 영문은 대문자로
    - 단수 명사로 표현하고 띄어쓰기는 하지 않음
    - 다른 엔터티와 의미상으로 중복될 수 없음

## 3) 속성(Attribute)

속성은 의미상 더 이상 쪼개지지 않는 레벨이어야 하고 프로세스에 필요한 항목이어야 한다. 예를 들어 국적이 속성에 있으나 업무상 불필요한 데이터라고 반단되면 삭제하는 것이 바람직하다.

- 관계
    - 한 개의 엔터티는 두 개 이상의 인스턴스를 갖는다
    - 한 개의 인스턴스는 두 개 이상의 속성을 갖는다
    - 한 개의 속성은 하나의 속성값을 갖는다.
- 특성에 따른 분류
    - 기본속성
        - 일반적인 속성으로 업무 프로세스 분석을 통해 바로 정의가 가능한 속성
    - 설계속성
        - 업무에 존재하지는 않지만 설계 과정에서 합리적인 모델링을 위해 인위적으로 만들어진 속성.
            - 에를 들어 유니크함을 위한 학번 생성한 경우 학번이 설계속성이다.
            - 주민번호는 원래 존재하는 속성이므로 기본속성에 속한다.
    - 파생속성
        - 다른 속성으로부터 파생된 속성으로 계산된 값이나 가공된 값이 이에 속한다.
            - 예를 들어 상품을 주문하여 결제하는 경우 미리 재고를 계산하여 속성으로 가지고 있는 경우 이것은 파생속성에 해당한다.
- 구성방식에 따른 분류
    - PK, FK, 일반
- 도메인: 속성이 가질 수 있는 속성값의 범위
    - ex) 학점이라는 속성의 속성값은 0.1~4.5 사이의 실수를 가질수 있는데 이 범위를 도메인이라고 한다
- 용어사전: 엔티티의 속성명을 정의할 때 명확한 의미의 이름을 부여하고 다른 엔터이와의 혼란을 예방하기 위해 이용한다.
- 시스템 카탈로그: 사용자 테이블과는 별개로 시스템 자체에 관련이 있는 데이터를 담고있는 데이터베이스이며, 시스템 테이블로 구성되어있다. SELECT만 가능하다.

## 4) 관계(Relationship)

엔터티간의 관계를 의미한다

- 존재 관계: 자손처럼 존재 자체로 연관성이 있는 관계를 의미한다.
- 행위 관계: 회원-주문과 같이 특정한 행위를 함으로써 연관성이 생기는 관계를 의미한다.
- 표기법
    - 관계명, 관계차수, 관계선택사양(필수인지 선택인지의 여부)

## 5) 식별자(Identifiers)

속성중에 각각의 인스턴스를 구분 가능하게 만들어주는 대표격인 속성을 의미한다.(학번. 군번, 사번 등)

- 주식별자(PK)
    - 하나의 속성이 주식별자가 될 수도 있고 여러 개의 속성이 주식별자가 될 수도 있다.
    - 특성
        - 유일성
        - 최소성: 유일성을 보장하는 최소 개수의 속성이어야 한다.
        - 불변성: 속성값이 되도록 변하지 않아야 한다.
        - 존재성: 속성값이 NULL일 수 없다.
- 분류
    - 대표성 여부
        - 주식별자
        - 보조식별자
    - 스스로  생성됐는지 여부
        - 내부식별자
        - 외부식별자
    - 단일 속성의 여부
        - 단일식별자
        - 복합식별자
    - 대체 여부
        - 본질식별자
        - 인조식별자
- 식별자 관계
    - 부모 엔터티의 식별자가 자식 엔터티의 주식별자가 되는 관계이다.
- 비식별자 관계
    - 부모엔터티의 식별자가 자식 엔터티의 주식별자가 아닌 일반 속성이 되는 관계이다.

## 적중예상문제

---

# PART 1 | CHAPTER 2 데이터 모델과 SQL

## 1) 정규화

데이터 정합성(정확성과 일관성을 유지하고 보장)을 위해 엔터티를 작은 단위로 분리하는 과정이다

### (1) 제1정규형

모든 속성은 반드시 하나의 값만 가져야 한다.

### (2) 제2정규형

엔터티의 모든 일반속성은 반드시 모든 주식별자에 종속되어야 한다. 

- 문제점 예시 46p

### (3) 제3정규형

주식별자가 아닌 모든 속성 간에는 서로 종속될 수 없다.

- 문제 풀 때 PK인지 여부를 확인하여 제2정규형과 헷갈림을 피하자 - 49p

## 2) 반정규화

- 데이터의 조회 성능을 향상시키기 위해 데이터의 중복을 허용하거나 데이터를 그룹핑하는 과정이다.
- 조회 성능은 향상될수 있으나 입력/수정/삭제 성능은 저하될 수 있으며 데이터 정합성 이슈가 발생할 수 있다.
- 반정규화의 과정은 정규화가 끝난 후 거치게 된다.

### (1) 테이블 반정규화

- 테이블 병합
    - 업무 프로레스상 JOIN이 필요한 경우가 많아 테이블을 통합하는 것이 성능 측면에서 유리할 경우 고려한다.
- 테이블 분할
    - 테이블 수직 분할: 엔터티의 일부 속성을 별도의 엔터티로 분할(1:1 관계 성립)한다.
    - 테이블 수평 분할: 엔터티의 인스턴스를 특정 기준으로 별도의 엔터티로 분할(파티셔닝)
        - 주문 → 주문(2023), 주문(2024)
- 테이블 추가
    - 중복 테이블 추가: 데이터의 중복을 감안하더라도 성능상 필요한 경우
    - 동계 테이블 추가: 통계치를 미리 계산하여 저장
    - 이력 테이블 추가: ex) 과거 상품가격에 대한 데이터를 관리
    - 부분 테이블 추가: ex) 회원 대상 메일 발송건이 다량으로 생기는 경우 메일 발송에 필요한 정보만 부분 테이블로 생성

### (2) 컬럼 반정규화

- 중복 컬럼 추가
    - JOIN이 필요한 경우가 많아 추가하는게 성능 측면에서 유리할 경우 고려
- 파생 컬럼 추가
    - 프로세스 수행 시 부하가 염려되는 계산값을 미리 컬럼으로 추가하여 보관하는 방식
- 이력 테이블 컬럼 추가
    - 대량의 이력 테이블을 조회할 때 속도가 느려질 것을 대비하여 조회 기준이 될 것으로 판단되는 컬럼을 미리 추가해 놓는 방식이다. 최신 데이터 여부 등이 해당

### (3) 관계 반정규화(중복 관계 추가)

업무 프로세스상 JOIN이 필요한 경우가 많아 중복 관계를 추가하는 것이 성능 측면에서 유리할 경우 고려한다.

## 3) 트랜잭션

데이터를 조작하기 위한 하나의 논리적인 작업 단위이다.

- 특징
    - 원자성
    - 일관성
    - 고립성
    - 지속성

## 4) NULL

- 가로 연산: NULL 이 포함돼있으면 결과값은 NULL이된다.
- 세로 연산: 다른 인스턴스의 데이터와 연산할 때는 NULL값을 제외한다.

## 5) 본질식별자 vs 인조식별자

- 본질식별자
    - 업무프로세스에 존재하는 식별자
    - 가공되지 않은 원래의 식별자
    - 원조식별자라고도 함
- 인조식별자
    - 주식별자의 속성이 두 개 이상인 경우 그 속성들을 하나로 묶어서 사용하는 식별자
        - ex) [주문번호+상품번호]로 구성된 주문목록번호
    - 대리식별자라고도 함

## 적중예상문제
